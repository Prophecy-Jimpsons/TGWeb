<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JIMP Tic Tac Toe</title>
    <script src="https://telegram.org/js/telegram-web-app.js" defer></script>
    <style>
      :root {
        --tg-theme-bg-color: #fff8e1;
        --tg-theme-text-color: #5d4037;
        --tg-theme-button-color: #ffa000;
        --tg-theme-button-text-color: #fff;
        --highlight-color: rgba(255, 160, 0, 0.2);
        --win-highlight: rgba(76, 175, 80, 0.3);
        --game-transition-duration: 0.3s;
        --cell-border-color: #ffb300;
        --shadow-color: rgba(255, 160, 0, 0.2);
        --winner-bg: rgba(76, 175, 80, 0.2);
        --container-width: min(95%, 400px);
      }

      body {
        background-color: var(--tg-theme-bg-color);
        color: var(--tg-theme-text-color);
        font-family: "Segoe UI", Arial, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        margin: 0;
        padding: 10px;
        min-height: 100vh;
        touch-action: manipulation;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        user-select: none;
        transition: all var(--game-transition-duration) ease;
        background-image: linear-gradient(
          45deg,
          #fff8e1 25%,
          #fff3e0 25%,
          #fff3e0 50%,
          #fff8e1 50%,
          #fff8e1 75%,
          #fff3e0 75%,
          #fff3e0 100%
        );
        background-size: 56.57px 56.57px;
      }

      .game-container {
        width: var(--container-width);
        margin: 0 auto;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 1rem;
      }

      .game-info {
        width: 100%;
        text-align: center;
        background: rgba(255, 255, 255, 0.8);
        padding: 0.75rem;
        border-radius: 1rem;
        box-shadow: 0 4px 6px var(--shadow-color);
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      .phase-indicator {
        font-size: clamp(1rem, 2.5vw, 1.25rem);
        color: var(--tg-theme-button-color);
        padding: 0.75rem;
        border-radius: 0.75rem;
        background: rgba(255, 160, 0, 0.1);
        box-shadow: 0 4px 6px var(--shadow-color);
        border: 2px solid var(--cell-border-color);
        margin: 0;
      }

      .pieces-count {
        font-size: clamp(0.875rem, 2vw, 1.125rem);
        font-weight: bold;
        color: var(--tg-theme-text-color);
        text-shadow: 1px 1px 0 rgba(255, 255, 255, 0.5);
        margin: 0;
      }

      .game-board {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: clamp(0.25rem, 1vw, 0.75rem);
        width: 100%;
        aspect-ratio: 1;
        background: rgba(255, 255, 255, 0.9);
        padding: clamp(0.5rem, 1.5vw, 1rem);
        border-radius: 1rem;
        box-shadow: 0 10px 20px var(--shadow-color);
      }

      .cell {
        aspect-ratio: 1;
        border: 2px solid var(--cell-border-color);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: clamp(1.25rem, 4vw, 1.75rem);
        font-weight: bold;
        cursor: pointer;
        background: #ffffff;
        transition: all 0.3s ease;
        cursor: pointer;
        transform-origin: center;
        border-radius: 0.75rem;
        box-shadow: 0 4px 8px var(--shadow-color);
        -webkit-tap-highlight-color: transparent;
        color: var(--tg-theme-button-color);
        position: relative;
        overflow: hidden;
      }

      .cell:hover:not(:disabled) {
        background-color: var(--highlight-color);
        transform: translateY(-2px);
        box-shadow: 0 6px 12px var(--shadow-color);
      }

      .cell:active {
        transform: scale(0.95);
        box-shadow: 0 2px 4px var(--shadow-color);
      }

      .cell.selected {
        box-shadow: 0 0 0 4px var(--tg-theme-button-color);
        animation: pulse 1.5s infinite;
        background-color: var(--highlight-color);
      }

      .cell.last-move {
        border: 3px solid #4caf50;
        animation: bounce 0.5s ease-in-out;
        background-color: rgba(76, 175, 80, 0.1);
      }

      .cell.winner {
        background-color: var(--winner-bg);
        border-color: #4caf50;
        animation: pulse 1.5s infinite;
      }

      .status {
        width: 100%;
        font-size: clamp(1rem, 2.5vw, 1.25rem);
        font-weight: bold;
        padding: clamp(0.75rem, 2vw, 1.25rem);
        border-radius: 1rem;
        background: rgba(255, 160, 0, 0.1);
        text-align: center;
        box-shadow: 0 4px 6px var(--shadow-color);
        border: 2px solid var(--cell-border-color);
        margin: 0;
        word-wrap: break-word;
        box-sizing: border-box;
      }

      .button-container {
        display: flex;
        gap: clamp(0.75rem, 2vw, 1.5rem);
        width: 100%;
        justify-content: center;
        margin-top: 1rem;
      }

      .main-button {
        background: var(--tg-theme-button-color);
        color: var(--tg-theme-button-text-color);
        border: none;
        padding: clamp(0.5rem, 1.5vw, 1rem) clamp(1rem, 3vw, 2rem);
        border-radius: 0.75rem;
        cursor: pointer;
        font-size: clamp(0.875rem, 2vw, 1.125rem);
        font-weight: bold;
        transition: all 0.3s ease;
        min-width: clamp(100px, 25vw, 140px);
        box-shadow: 0 4px 8px var(--shadow-color);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        white-space: nowrap;
      }

      .main-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 12px var(--shadow-color);
        background: #ff8f00;
      }

      .main-button:active {
        transform: scale(0.95);
        box-shadow: 0 2px 4px var(--shadow-color);
      }

      .winner {
        color: #4caf50;
        font-weight: bold;
        animation: bounce 1s ease-in-out;
        text-shadow: 1px 1px 0 rgba(255, 255, 255, 0.5);
      }

      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(0.95);
        }
      }

      @keyframes bounce {
        0%,
        100% {
          transform: translateY(0);
        }
        50% {
          transform: translateY(-5px);
        }
      }

      @keyframes spin {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }

      @media (max-width: 360px) {
        :root {
          --container-width: 100%;
        }

        body {
          padding: 5px;
        }

        .game-board {
          gap: 0.25rem;
          padding: 0.35rem;
        }

        .cell {
          border-radius: 0.5rem;
        }

        .main-button {
          padding: 0.5rem;
          min-width: 90px;
          font-size: 0.75rem;
        }
      }

      @media (min-width: 361px) and (max-width: 640px) {
        body {
          padding: 10px;
        }

        .game-board {
          gap: 0.35rem;
          padding: 0.5rem;
        }

        .button-container {
          gap: 1rem;
        }
      }

      @media (min-width: 641px) {
        :root {
          --container-width: min(95%, 500px);
        }

        .cell:hover {
          transform: translateY(-3px);
          box-shadow: 0 8px 16px var(--shadow-color);
        }
      }

      @media (prefers-color-scheme: dark) {
        :root {
          --tg-theme-bg-color: #2d2d2d;
          --tg-theme-text-color: #fff8e1;
          --tg-theme-button-color: #ffa000;
          --highlight-color: rgba(255, 160, 0, 0.2);
          --shadow-color: rgba(0, 0, 0, 0.3);
        }

        body {
          background-image: linear-gradient(
            45deg,
            #2d2d2d 25%,
            #333333 25%,
            #333333 50%,
            #2d2d2d 50%,
            #2d2d2d 75%,
            #333333 75%,
            #333333 100%
          );
        }

        .cell {
          background: #3d3d3d;
          color: #ffd54f;
        }

        .game-info,
        .game-board {
          background: rgba(0, 0, 0, 0.2);
        }

        .status,
        .phase-indicator {
          background: rgba(255, 160, 0, 0.1);
          border-color: var(--tg-theme-button-color);
        }
      }
    </style>
  </head>
  <body>
    <!-- Game Info Header -->
    <div class="game-info">
      <button id="joinButton">Join</button>
      <div id="status"></div>
      <div id="turn-indicator"></div>
    </div>

    <!-- The Board or Grid -->
    <div class="board">
      <!-- Example 4x4 board cells -->
      <div class="row">
        <div class="cell" data-row="0" data-col="0"></div>
        <div class="cell" data-row="0" data-col="1"></div>
        <div class="cell" data-row="0" data-col="2"></div>
        <div class="cell" data-row="0" data-col="3"></div>
      </div>
      <div class="row">
        <div class="cell" data-row="1" data-col="0"></div>
        <div class="cell" data-row="1" data-col="1"></div>
        <div class="cell" data-row="1" data-col="2"></div>
        <div class="cell" data-row="1" data-col="3"></div>
      </div>
      <div class="row">
        <div class="cell" data-row="2" data-col="0"></div>
        <div class="cell" data-row="2" data-col="1"></div>
        <div class="cell" data-row="2" data-col="2"></div>
        <div class="cell" data-row="2" data-col="3"></div>
      </div>
      <div class="row">
        <div class="cell" data-row="3" data-col="0"></div>
        <div class="cell" data-row="3" data-col="1"></div>
        <div class="cell" data-row="3" data-col="2"></div>
        <div class="cell" data-row="3" data-col="3"></div>
      </div>
    </div>

    <script>
      // Hidden name input HTML to be inserted after the .game-info div
      const nameInputHTML = `
        <div class="game-info">
          <input type="text" id="nameInput" 
            placeholder="Enter your name" 
            style="display: none; 
                   padding: 8px;
                   border-radius: 8px;
                   border: 2px solid var(--cell-border-color);
                   margin: 10px 0;"
          >
        </div>
      `;

      // Global variables
      let lastUpdate = 0;
      const DEBOUNCE_TIME = 100;
      let isProcessingUpdate = false;
      let isProcessingMove = false;
      const POLLING_INTERVAL = 3000; // example polling interval
      const API_URL = "https://your-api-endpoint.example.com";

      // Telegram reference
      let tg = window.Telegram?.WebApp || { initDataUnsafe: {} };

      // GameState class to store and update game state
      class GameState {
        constructor() {
          this.state = {
            board: [],
            currentTurn: null,
            mySymbol: null,
            selectedPiece: null,
            lastMove: null,
            winner: null,
            isGameOver: false,
          };
        }

        update(newState) {
          if (!newState) return;
          // Debounce or skip if too soon
          if (Date.now() - lastUpdate < DEBOUNCE_TIME) return;
          if (isProcessingUpdate) return;

          isProcessingUpdate = true;
          try {
            // Check if there's any difference
            const hasChanges = Object.keys(newState).some(
              (key) =>
                JSON.stringify(this.state[key]) !==
                JSON.stringify(newState[key])
            );
            if (hasChanges) {
              this.state = { ...this.state, ...newState };
              requestAnimationFrame(() => {
                updateBoard();
                updateGameStatus();
              });
              lastUpdate = Date.now();
            }
          } finally {
            isProcessingUpdate = false;
          }
        }

        // Click handler for cells
        async handleCellClick(event) {
          if (!event.target.classList.contains("cell")) return;
          const row = parseInt(event.target.dataset.row);
          const col = parseInt(event.target.dataset.col);

          // Example validity checks
          if (!this.isValidTurn()) return;
          if (!this.isValidMove(row, col)) return;

          try {
            isProcessingMove = true;
            await this.processMove({ row, col, type: "placement" });
          } finally {
            isProcessingMove = false;
          }
        }

        // Example placeholders
        isValidTurn() {
          return (
            this.state.currentTurn === this.state.mySymbol &&
            !this.state.isGameOver
          );
        }

        isValidMove(row, col) {
          if (!this.state.board[row]) return false;
          // Add custom logic for checking valid moves
          return true;
        }

        async processMove(moveData) {
          const response = await makeApiCall("make_move", moveData);
          if (response.success && response.gameState) {
            this.update(response.gameState);
          }
        }
      }

      // Instantiate GameState
      const gameState = new GameState();

      // Insert the name input markup once DOM is available, then set up game
      document.addEventListener("DOMContentLoaded", () => {
        document
          .querySelector(".game-info")
          .insertAdjacentHTML("afterend", nameInputHTML);

        initializeGame();
        initializePolling();
      });

      // Initialize the game and attach event listeners
      function initializeGame() {
        // Attach cell click listeners
        const cells = document.querySelectorAll(".cell");
        cells.forEach((cell) => {
          cell.addEventListener("click", (e) => {
            gameState.handleCellClick(e);
          });
        });

        // Attach join click listener
        const joinButton = document.getElementById("joinButton");
        if (joinButton) {
          joinButton.addEventListener("click", handleJoin);
        }
      }

      // Polling for game status
      function initializePolling() {
        setInterval(checkGameStatus, POLLING_INTERVAL);
      }

      // Check server for updated game status
      async function checkGameStatus() {
        try {
          const response = await makeApiCall("get_game_state", {});
          if (response.success && response.gameState) {
            gameState.update(response.gameState);
          }
        } catch (error) {
          console.error("Error fetching game state:", error);
        }
      }

      // Join the game with Telegram username or user input
      async function handleJoin() {
        if (gameState.state.mySymbol) {
          document.getElementById(
            "status"
          ).textContent = `You are already in the game as ${gameState.state.mySymbol}`;
          return;
        }

        let username;
        if (tg.initDataUnsafe.user?.username) {
          username = tg.initDataUnsafe.user.username;
        } else {
          const nameInput = document.getElementById("nameInput");
          nameInput.style.display = "block";
          username = await new Promise((resolve) => {
            nameInput.addEventListener("keypress", (e) => {
              if (e.key === "Enter" && nameInput.value.trim()) {
                nameInput.style.display = "none";
                resolve(nameInput.value.trim());
              }
            });
          });
        }

        try {
          const response = await makeApiCall("join_game", { username });
          if (response.isAlreadyJoined) {
            document.getElementById("status").textContent = response.message;
            return;
          }
          if (response.success) {
            gameState.state.mySymbol = response.gameState.mySymbol;
            gameState.update(response.gameState);
            document.getElementById(
              "status"
            ).textContent = `You joined as ${response.gameState.mySymbol}`;
          } else {
            document.getElementById("status").textContent = response.message;
          }
        } catch (error) {
          console.error("Join error:", error);
          document.getElementById("status").textContent = "Error joining game";
        }
      }

      // Make a generic API call with optional retries
      async function makeApiCall(endpoint, data, retries = 3) {
        for (let i = 0; i < retries; i++) {
          try {
            const response = await fetch(`${API_URL}/${endpoint}`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                ...data,
                chatId: tg.initDataUnsafe.chat?.id || "default",
                userId: tg.initDataUnsafe.user?.id || "anon",
                timestamp: Date.now(),
              }),
            });
            const result = await response.json();
            if (result.message?.includes("already in the game")) {
              return {
                success: false,
                isAlreadyJoined: true,
                message: result.message,
              };
            }
            return result;
          } catch (error) {
            console.error(`Error calling ${endpoint}:`, error);
            if (i === retries - 1) throw error;
            // Exponential backoff example
            await new Promise((resolve) => setTimeout(resolve, 1000 * (i + 1)));
          }
        }
      }

      // Update board based on current game state
      function updateBoard() {
        if (!gameState.state.board) return;

        requestAnimationFrame(() => {
          try {
            const cells = document.querySelectorAll(".cell");
            const board = gameState.state.board;
            cells.forEach((cell, index) => {
              const row = Math.floor(index / 4);
              const col = index % 4;
              cell.className = "cell";
              const piece = board[row][col] || "";
              cell.textContent = piece;

              if (piece) {
                cell.classList.add(`piece-${piece.toLowerCase()}`);
                if (
                  gameState.state.selectedPiece?.row === row &&
                  gameState.state.selectedPiece?.col === col
                ) {
                  cell.classList.add("selected");
                }
              }
              if (
                gameState.state.lastMove?.row === row &&
                gameState.state.lastMove?.col === col
              ) {
                cell.classList.add("last-move");
              }
            });
          } catch (error) {
            console.error("Board update error:", error);
          }
        });
      }

      // Update status: turn indicator, game over screen, etc.
      function updateGameStatus() {
        const statusElement = document.getElementById("status");
        if (!statusElement) return;
        const turnIndicator = document.getElementById("turn-indicator");
        if (!turnIndicator) return;

        const { winner, currentTurn, isGameOver } = gameState.state;
        if (isGameOver) {
          statusElement.textContent = winner
            ? `Game Over! ${winner} wins!`
            : "Game Over! It's a draw!";
        } else {
          statusElement.textContent = "";
        }

        turnIndicator.textContent = isGameOver
          ? ""
          : `Current Turn: ${currentTurn}`;
      }
    </script>
  </body>
</html>
