<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JIMP Tic Tac Toe</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root {
            --tg-theme-bg-color: #fff8e1;
            --tg-theme-text-color: #5d4037;
            --tg-theme-button-color: #ffa000;
            --tg-theme-button-text-color: #fff;
            --highlight-color: rgba(255, 160, 0, 0.2);
            --win-highlight: rgba(76, 175, 80, 0.3);
            --game-transition-duration: 0.3s;
            --cell-border-color: #ffb300;
            --shadow-color: rgba(255, 160, 0, 0.2);
            --winner-bg: rgba(76, 175, 80, 0.2);
            --container-width: min(95%, 400px);
        }
    
        body {
            background-color: var(--tg-theme-bg-color);
            color: var(--tg-theme-text-color);
            font-family: 'Segoe UI', Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 10px;
            min-height: 100vh;
            touch-action: manipulation;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            transition: all var(--game-transition-duration) ease;
            background-image: linear-gradient(45deg, #fff8e1 25%, #fff3e0 25%, #fff3e0 50%, #fff8e1 50%, #fff8e1 75%, #fff3e0 75%, #fff3e0 100%);
            background-size: 56.57px 56.57px;
        }
    
        .game-container {
            width: var(--container-width);
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }
    
        .game-info {
            width: 100%;
            text-align: center;
            background: rgba(255, 255, 255, 0.8);
            padding: 0.75rem;
            border-radius: 1rem;
            box-shadow: 0 4px 6px var(--shadow-color);
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
    
        .phase-indicator {
            font-size: clamp(1rem, 2.5vw, 1.25rem);
            color: var(--tg-theme-button-color);
            padding: 0.75rem;
            border-radius: 0.75rem;
            background: rgba(255, 160, 0, 0.1);
            box-shadow: 0 4px 6px var(--shadow-color);
            border: 2px solid var(--cell-border-color);
            margin: 0;
        }
    
        .pieces-count {
            font-size: clamp(0.875rem, 2vw, 1.125rem);
            font-weight: bold;
            color: var(--tg-theme-text-color);
            text-shadow: 1px 1px 0 rgba(255, 255, 255, 0.5);
            margin: 0;
        }
    
        .game-board {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: clamp(0.25rem, 1vw, 0.75rem);
            width: 100%;
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.9);
            padding: clamp(0.5rem, 1.5vw, 1rem);
            border-radius: 1rem;
            box-shadow: 0 10px 20px var(--shadow-color);
        }
    
        .cell {
            aspect-ratio: 1;
            border: 2px solid var(--cell-border-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(1.25rem, 4vw, 1.75rem);
            font-weight: bold;
            cursor: pointer;
            background: #ffffff;
            transition: all 0.3s ease;
            border-radius: 0.75rem;
            box-shadow: 0 4px 8px var(--shadow-color);
            -webkit-tap-highlight-color: transparent;
            color: var(--tg-theme-button-color);
            position: relative;
            overflow: hidden;
        }

        .cell:hover:not(:disabled) {
        background-color: var(--highlight-color);
        transform: translateY(-2px);
        box-shadow: 0 6px 12px var(--shadow-color);
    }

    .cell:active {
        transform: scale(0.95);
        box-shadow: 0 2px 4px var(--shadow-color);
    }

    .cell.selected {
        box-shadow: 0 0 0 4px var(--tg-theme-button-color);
        animation: pulse 1.5s infinite;
        background-color: var(--highlight-color);
    }

    .cell.last-move {
        border: 3px solid #4CAF50;
        animation: bounce 0.5s ease-in-out;
        background-color: rgba(76, 175, 80, 0.1);
    }

    .cell.winner {
        background-color: var(--winner-bg);
        border-color: #4CAF50;
        animation: pulse 1.5s infinite;
    }

    .status {
        width: 100%;
        font-size: clamp(1rem, 2.5vw, 1.25rem);
        font-weight: bold;
        padding: clamp(0.75rem, 2vw, 1.25rem);
        border-radius: 1rem;
        background: rgba(255, 160, 0, 0.1);
        text-align: center;
        box-shadow: 0 4px 6px var(--shadow-color);
        border: 2px solid var(--cell-border-color);
        margin: 0;
        word-wrap: break-word;
        box-sizing: border-box;
    }

    .button-container {
        display: flex;
        gap: clamp(0.75rem, 2vw, 1.5rem);
        width: 100%;
        justify-content: center;
        margin-top: 1rem;
    }

    .main-button {
        background: var(--tg-theme-button-color);
        color: var(--tg-theme-button-text-color);
        border: none;
        padding: clamp(0.5rem, 1.5vw, 1rem) clamp(1rem, 3vw, 2rem);
        border-radius: 0.75rem;
        cursor: pointer;
        font-size: clamp(0.875rem, 2vw, 1.125rem);
        font-weight: bold;
        transition: all 0.3s ease;
        min-width: clamp(100px, 25vw, 140px);
        box-shadow: 0 4px 8px var(--shadow-color);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        white-space: nowrap;
    }

    .main-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 12px var(--shadow-color);
        background: #ff8f00;
    }

    .main-button:active {
        transform: scale(0.95);
        box-shadow: 0 2px 4px var(--shadow-color);
    }

    .winner {
        color: #4CAF50;
        font-weight: bold;
        animation: bounce 1s ease-in-out;
        text-shadow: 1px 1px 0 rgba(255, 255, 255, 0.5);
    }

    @keyframes pulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(0.95); }
    }

    @keyframes bounce {
        0%, 100% { transform: translateY(0); }
        50% { transform: translateY(-5px); }
    }

    @keyframes spin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }

    @media (max-width: 360px) {
        :root {
            --container-width: 100%;
        }

        body {
            padding: 5px;
        }

        .game-board {
            gap: 0.25rem;
            padding: 0.35rem;
        }

        .cell {
            border-radius: 0.5rem;
        }

        .main-button {
            padding: 0.5rem;
            min-width: 90px;
            font-size: 0.75rem;
        }
    }

    @media (min-width: 361px) and (max-width: 640px) {
        body {
            padding: 10px;
        }

        .game-board {
            gap: 0.35rem;
            padding: 0.5rem;
        }

        .button-container {
            gap: 1rem;
        }
    }

    @media (min-width: 641px) {
        :root {
            --container-width: min(95%, 500px);
        }

        .cell:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 16px var(--shadow-color);
        }
    }

    @media (prefers-color-scheme: dark) {
        :root {
            --tg-theme-bg-color: #2d2d2d;
            --tg-theme-text-color: #fff8e1;
            --tg-theme-button-color: #ffa000;
            --highlight-color: rgba(255, 160, 0, 0.2);
            --shadow-color: rgba(0, 0, 0, 0.3);
        }

        body {
            background-image: linear-gradient(45deg, #2d2d2d 25%, #333333 25%, #333333 50%, #2d2d2d 50%, #2d2d2d 75%, #333333 75%, #333333 100%);
        }

        .cell {
            background: #3d3d3d;
            color: #ffd54f;
        }

        .game-info, .game-board {
            background: rgba(0, 0, 0, 0.2);
        }

        .status, .phase-indicator {
            background: rgba(255, 160, 0, 0.1);
            border-color: var(--tg-theme-button-color);
        }
    }
</style>

</head>
<body>
    <div class="game-info">
        <div class="status" id="status">Welcome to Super Tic Tac Toe!</div>
        <div class="phase-indicator" id="phaseIndicator"></div>
        <div class="pieces-count" id="piecesCount"></div>
    </div>
    
    <div id="game-board" class="game-board"></div>
    
    <div class="button-container">
        <button class="main-button" id="joinBtn">Join Game</button>
        <button class="main-button" id="resetBtn">New Game</button>
    </div>

    <script>
        let tg = window.Telegram.WebApp;
        const API_URL = 'https://pjimpsons.pythonanywhere.com';
        let socket = null;
        let lastStateUpdate = Date.now();
        const STATE_UPDATE_INTERVAL = 1000; // 1 second
        const RETRY_INTERVAL = 2000; // 2 seconds
        let retryCount = 0;
        const MAX_RETRIES = 3;
        
        // Cache for storing game state
        const stateCache = {
            lastFullState: null,
            lastUpdateTime: 0,
            deltaUpdates: [],
            CACHE_DURATION: 5000 // 5 seconds
        };

        // Debounce function for handling rapid state updates
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Throttle function for API calls
        function throttle(func, limit) {
            let inThrottle;
            return function(...args) {
                if (!inThrottle) {
                    func.apply(this, args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit);
                }
            }
        }

        // Initialize WebSocket connection
        function initializeWebSocket() {
            if (socket) {
                socket.close();
            }

            const wsUrl = API_URL.replace('https', 'wss') + '/ws';
            socket = new WebSocket(wsUrl);

            socket.onopen = () => {
                console.log('WebSocket connected');
                retryCount = 0;
                socket.send(JSON.stringify({
                    type: 'init',
                    chatId: tg.initDataUnsafe.chat?.id || 'default',
                    userId: tg.initDataUnsafe.user?.id
                }));
            };

            socket.onclose = () => {
                console.log('WebSocket disconnected');
                if (retryCount < MAX_RETRIES) {
                    setTimeout(() => {
                        retryCount++;
                        initializeWebSocket();
                    }, RETRY_INTERVAL * retryCount);
                }
            };

            socket.onerror = (error) => {
                console.error('WebSocket error:', error);
            };

            // Handle incoming WebSocket messages
            socket.onmessage = (event) => {
                const data = JSON.parse(event.data);
                handleStateUpdate(data);
            };
        }

        // Handle state updates from WebSocket
        function handleStateUpdate(data) {
            if (data.type === 'fullState') {
                stateCache.lastFullState = data.state;
                stateCache.lastUpdateTime = Date.now();
                stateCache.deltaUpdates = [];
                updateGameState(data.state);
            } else if (data.type === 'deltaUpdate') {
                stateCache.deltaUpdates.push(data.delta);
                applyDeltaUpdate(data.delta);
            }
        }

        // Apply delta updates to current state
        function applyDeltaUpdate(delta) {
            if (!stateCache.lastFullState) return;
            
            Object.keys(delta).forEach(key => {
                if (typeof delta[key] === 'object' && delta[key] !== null) {
                    stateCache.lastFullState[key] = {
                        ...stateCache.lastFullState[key],
                        ...delta[key]
                    };
                } else {
                    stateCache.lastFullState[key] = delta[key];
                }
            });

            updateGameState(stateCache.lastFullState);
        }

        // Initialize the game
        document.addEventListener('DOMContentLoaded', () => {
            initializeWebSocket();
            initializeGame();
        });


        class GameState {
            constructor() {
                this.state = {
                    board: Array(4).fill().map(() => Array(4).fill('')),
                    currentPlayer: '',
                    mySymbol: null,
                    phase: 'placement',
                    pieces: { O: 0, X: 0 },
                    selectedPiece: null,
                    lastMove: null,
                    gameEnded: false,
                    winner: null,
                    players: {},
                    joinTimeout: 60000,
                    placementTimeout: 60000,
                    lastActivityTime: Date.now()
                };
                this.lastUpdate = Date.now();
                this.isProcessingMove = false;
                this.moveQueue = [];
                this.processingQueue = false;
            }

            // Process moves in queue
            async processMoveQueue() {
                if (this.processingQueue || this.moveQueue.length === 0) return;
                
                this.processingQueue = true;
                while (this.moveQueue.length > 0) {
                    const move = this.moveQueue.shift();
                    try {
                        await this.processMove(move);
                    } catch (error) {
                        console.error('Move processing error:', error);
                    }
                }
                this.processingQueue = false;
            }

            // Add move to queue
            queueMove(move) {
                this.moveQueue.push(move);
                this.processMoveQueue();
            }

            async processMove(move) {
                const { row, col, type } = move;
                if (type === 'placement') {
                    await this.handlePlacement(row, col);
                } else {
                    await this.handleMovement(row, col);
                }
            }

            shouldUpdate(newState) {
                if (!newState || Date.now() - this.lastUpdate < 100) return false;
                
                // Compare only relevant state changes
                const relevantKeys = ['board', 'currentPlayer', 'phase', 'pieces', 'gameEnded', 'winner'];
                return relevantKeys.some(key => 
                    JSON.stringify(this.state[key]) !== JSON.stringify(newState[key])
                );
            }

            update(newState) {
                if (!this.shouldUpdate(newState)) return;

                // Create delta update
                const delta = {};
                Object.keys(newState).forEach(key => {
                    if (JSON.stringify(this.state[key]) !== JSON.stringify(newState[key])) {
                        delta[key] = newState[key];
                    }
                });

                // Update state and trigger UI updates
                this.state = {...this.state, ...newState};
                this.lastUpdate = Date.now();
                
                // Send delta update through WebSocket if connected
                if (socket && socket.readyState === WebSocket.OPEN) {
                    socket.send(JSON.stringify({
                        type: 'deltaUpdate',
                        delta: delta,
                        chatId: tg.initDataUnsafe.chat?.id || 'default'
                    }));
                }

                this.updateUI();
            }

            updateUI() {
                requestAnimationFrame(() => {
                    updateBoard();
                    updateStatus();
                    updatePlayerDisplay();
                    updatePhaseIndicator();
                });
            }

            isValidTurn() {
                return (
                    this.state.mySymbol && 
                    this.state.currentPlayer === this.state.mySymbol && 
                    !this.state.gameEnded &&
                    !this.isProcessingMove
                );
            }

            isValidMove(row, col) {
                if (this.state.phase === 'placement') {
                    return this.state.board[row][col] === '' && 
                           this.state.pieces[this.state.mySymbol] < 4;
                } else {
                    if (!this.state.selectedPiece) {
                        return this.state.board[row][col] === this.state.mySymbol;
                    }
                    // Add move validation logic for movement phase
                    const { row: fromRow, col: fromCol } = this.state.selectedPiece;
                    const rowDiff = Math.abs(row - fromRow);
                    const colDiff = Math.abs(col - fromCol);
                    return (rowDiff <= 1 && colDiff <= 1) && 
                           this.state.board[row][col] === '';
                }
            }

            handleCellClick = debounce(async (event) => {
                if (!this.isValidTurn()) return;

                const row = parseInt(event.target.dataset.row);
                const col = parseInt(event.target.dataset.col);

                if (!this.isValidMove(row, col)) return;

                try {
                    this.isProcessingMove = true;
                    const moveType = this.state.phase === 'placement' ? 'placement' : 'movement';
                    this.queueMove({ row, col, type: moveType });
                } catch (error) {
                    console.error('Move error:', error);
                } finally {
                    this.isProcessingMove = false;
                }
            }, 250);

            async handlePlacement(row, col) {
                if (!this.isValidMove(row, col)) return;
                return await makeMove(row, col);
            }

            async handleMovement(row, col) {
                if (!this.state.selectedPiece && 
                    this.state.board[row][col] === this.state.mySymbol) {
                    this.state.selectedPiece = {row, col};
                    this.updateUI();
                    return;
                }
                
                if (this.state.selectedPiece && this.isValidMove(row, col)) {
                    const result = await makeMove(row, col, this.state.selectedPiece);
                    this.state.selectedPiece = null;
                    return result;
                }
            }
        }

        const gameState = new GameState();

                // WebSocket message handling
                async function handleWebSocketMessage(event) {
            const data = JSON.parse(event.data);
            if (data.type === 'state_update') {
                gameState.update(data.state);
            }
        }

        // API calls with built-in retry logic
        async function makeApiCall(endpoint, data, retries = 3) {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(`${API_URL}/${endpoint}`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({
                            ...data,
                            chatId: tg.initDataUnsafe.chat?.id || 'default',
                            userId: tg.initDataUnsafe.user?.id,
                            timestamp: Date.now()
                        })
                    });
                    return await response.json();
                } catch (error) {
                    if (i === retries - 1) throw error;
                    await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
                }
            }
        }

        async function makeMove(row, col, selectedPiece = null) {
            try {
                const response = await makeApiCall('make_move', {
                    row, 
                    col,
                    symbol: gameState.state.mySymbol,
                    selectedPiece
                });

                if (response.success) {
                    gameState.state.selectedPiece = null;
                    return true;
                }
                
                document.getElementById('status').textContent = response.message;
                return false;
            } catch (error) {
                console.error('Move error:', error);
                document.getElementById('status').textContent = 'Error making move';
                return false;
            }
        }

        const throttledGameStateCheck = throttle(async () => {
            if (!socket || socket.readyState !== WebSocket.OPEN) {
                try {
                    const response = await makeApiCall('get_game_state', {});
                    if (response.success) {
                        gameState.update(response.gameState);
                    }
                } catch (error) {
                    console.error('State check error:', error);
                }
            }
        }, 1000);

        async function handleJoin() {
            try {
                const response = await makeApiCall('join_game', {
                    username: tg.initDataUnsafe.user?.username || 'Player'
                });
                
                if (response.success) {
                    gameState.state.mySymbol = response.gameState.mySymbol;
                    gameState.update(response.gameState);
                    document.getElementById('status').textContent = 
                        `You joined as ${response.gameState.mySymbol}`;
                } else {
                    document.getElementById('status').textContent = response.message;
                }
            } catch (error) {
                console.error('Join error:', error);
                document.getElementById('status').textContent = 'Error joining game';
            }
        }

        async function resetGame() {
            try {
                const response = await makeApiCall('reset_game', {});
                if (response.success) {
                    gameState.state.mySymbol = null;
                    gameState.state.selectedPiece = null;
                    gameState.update(response.gameState);
                }
            } catch (error) {
                console.error('Reset error:', error);
            }
        }

                // UI Update Functions
                function updateBoard() {
            const cells = document.querySelectorAll('.cell');
            const winningPattern = getWinningPattern(gameState.state.board, gameState.state.winner);
            
            requestAnimationFrame(() => {
                cells.forEach((cell, index) => {
                    const row = Math.floor(index / 4);
                    const col = index % 4;
                    cell.textContent = gameState.state.board[row][col];
                    cell.className = 'cell';
                    
                    if (gameState.state.gameEnded && gameState.state.winner && winningPattern) {
                        if (winningPattern.some(([r, c]) => r === row && c === col)) {
                            cell.classList.add('winner');
                        }
                    }
                    
                    if (gameState.state.selectedPiece && 
                        row === gameState.state.selectedPiece.row && 
                        col === gameState.state.selectedPiece.col) {
                        cell.classList.add('selected');
                    }
                    
                    if (gameState.state.lastMove && 
                        row === gameState.state.lastMove[0] && 
                        col === gameState.state.lastMove[1]) {
                        cell.classList.add('last-move');
                    }
                });
            });
        }

        function updateStatus() {
            const statusDiv = document.getElementById('status');
            requestAnimationFrame(() => {
                if (gameState.state.gameEnded && gameState.state.winner) {
                    const winnerName = gameState.state.players[gameState.state.winner];
                    statusDiv.textContent = `${winnerName} (${gameState.state.winner}) has won! 🎉`;
                } else if (Object.keys(gameState.state.players).length < 2) {
                    statusDiv.textContent = 'Waiting for players...';
                } else {
                    const isMyTurn = gameState.state.currentPlayer === gameState.state.mySymbol;
                    const currentPlayerName = gameState.state.players[gameState.state.currentPlayer];
                    statusDiv.textContent = isMyTurn ? 'Your turn!' : 
                        `Waiting for ${currentPlayerName}'s (${gameState.state.currentPlayer}) move...`;
                }
            });
        }

        function updatePlayerDisplay() {
            const phaseDiv = document.getElementById('phaseIndicator');
            requestAnimationFrame(() => {
                const playersInfo = Object.entries(gameState.state.players)
                    .map(([symbol, name]) => `${symbol}: ${name}`)
                    .join(' vs ');
                phaseDiv.textContent = playersInfo;
            });
        }

        function updatePhaseIndicator() {
            const piecesDiv = document.getElementById('piecesCount');
            requestAnimationFrame(() => {
                if (gameState.state.phase === 'placement') {
                    piecesDiv.textContent = `Pieces - X: ${gameState.state.pieces.X}/4, O: ${gameState.state.pieces.O}/4`;
                } else {
                    piecesDiv.textContent = 'Move phase: Move your pieces to win!';
                }
            });
        }

        // Event Listeners
        document.getElementById('joinBtn').addEventListener('click', handleJoin);
        document.getElementById('resetBtn').addEventListener('click', resetGame);

        // Initialize game and start WebSocket connection
        initializeGame();
        initializeWebSocket();
    </script>
</body>
</html>
