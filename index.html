<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JIMP Tic Tac Toe</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
      :root {
        --tg-theme-bg-color: #fff8e1;
        --tg-theme-text-color: #5d4037;
        --tg-theme-button-color: #ffa000;
        --tg-theme-button-text-color: #fff;
        --highlight-color: rgba(255, 160, 0, 0.2);
        --win-highlight: rgba(76, 175, 80, 0.3);
        --game-transition-duration: 0.3s;
        --cell-border-color: #ffb300;
        --shadow-color: rgba(255, 160, 0, 0.2);
        --winner-bg: rgba(76, 175, 80, 0.2);
        --container-width: min(95%, 400px);
      }

      body {
        background-color: var(--tg-theme-bg-color);
        color: var(--tg-theme-text-color);
        font-family: "Segoe UI", Arial, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        margin: 0;
        padding: 10px;
        min-height: 100vh;
        touch-action: manipulation;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        user-select: none;
        transition: all var(--game-transition-duration) ease;
        background-image: linear-gradient(
          45deg,
          #fff8e1 25%,
          #fff3e0 25%,
          #fff3e0 50%,
          #fff8e1 50%,
          #fff8e1 75%,
          #fff3e0 75%,
          #fff3e0 100%
        );
        background-size: 56.57px 56.57px;
      }

      .game-container {
        width: var(--container-width);
        margin: 0 auto;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 1rem;
      }

      .game-info {
        width: 100%;
        text-align: center;
        background: rgba(255, 255, 255, 0.8);
        padding: 0.75rem;
        border-radius: 1rem;
        box-shadow: 0 4px 6px var(--shadow-color);
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      .phase-indicator {
        font-size: clamp(1rem, 2.5vw, 1.25rem);
        color: var(--tg-theme-button-color);
        padding: 0.75rem;
        border-radius: 0.75rem;
        background: rgba(255, 160, 0, 0.1);
        box-shadow: 0 4px 6px var(--shadow-color);
        border: 2px solid var(--cell-border-color);
        margin: 0;
      }

      .pieces-count {
        font-size: clamp(0.875rem, 2vw, 1.125rem);
        font-weight: bold;
        color: var(--tg-theme-text-color);
        text-shadow: 1px 1px 0 rgba(255, 255, 255, 0.5);
        margin: 0;
      }

      .game-board {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: clamp(0.25rem, 1vw, 0.75rem);
        width: 100%;
        aspect-ratio: 1;
        background: rgba(255, 255, 255, 0.9);
        padding: clamp(0.5rem, 1.5vw, 1rem);
        border-radius: 1rem;
        box-shadow: 0 10px 20px var(--shadow-color);
      }

      .cell {
        aspect-ratio: 1;
        border: 2px solid var(--cell-border-color);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: clamp(1.25rem, 4vw, 1.75rem);
        font-weight: bold;
        cursor: pointer;
        background: #ffffff;
        transition: all 0.3s ease;
        border-radius: 0.75rem;
        box-shadow: 0 4px 8px var(--shadow-color);
        -webkit-tap-highlight-color: transparent;
        color: var(--tg-theme-button-color);
        position: relative;
        overflow: hidden;
      }

      .cell:hover:not(:disabled) {
        background-color: var(--highlight-color);
        transform: translateY(-2px);
        box-shadow: 0 6px 12px var(--shadow-color);
      }

      .cell:active {
        transform: scale(0.95);
        box-shadow: 0 2px 4px var(--shadow-color);
      }

      .cell.selected {
        box-shadow: 0 0 0 4px var(--tg-theme-button-color);
        animation: pulse 1.5s infinite;
        background-color: var(--highlight-color);
      }

      .cell.last-move {
        border: 3px solid #4caf50;
        animation: bounce 0.5s ease-in-out;
        background-color: rgba(76, 175, 80, 0.1);
      }

      .cell.winner {
        background-color: var(--winner-bg);
        border-color: #4caf50;
        animation: pulse 1.5s infinite;
      }

      .status {
        width: 100%;
        font-size: clamp(1rem, 2.5vw, 1.25rem);
        font-weight: bold;
        padding: clamp(0.75rem, 2vw, 1.25rem);
        border-radius: 1rem;
        background: rgba(255, 160, 0, 0.1);
        text-align: center;
        box-shadow: 0 4px 6px var(--shadow-color);
        border: 2px solid var(--cell-border-color);
        margin: 0;
        word-wrap: break-word;
        box-sizing: border-box;
      }

      .button-container {
        display: flex;
        gap: clamp(0.75rem, 2vw, 1.5rem);
        width: 100%;
        justify-content: center;
        margin-top: 1rem;
      }

      .main-button {
        background: var(--tg-theme-button-color);
        color: var(--tg-theme-button-text-color);
        border: none;
        padding: clamp(0.5rem, 1.5vw, 1rem) clamp(1rem, 3vw, 2rem);
        border-radius: 0.75rem;
        cursor: pointer;
        font-size: clamp(0.875rem, 2vw, 1.125rem);
        font-weight: bold;
        transition: all 0.3s ease;
        min-width: clamp(100px, 25vw, 140px);
        box-shadow: 0 4px 8px var(--shadow-color);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        white-space: nowrap;
      }

      .main-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 12px var(--shadow-color);
        background: #ff8f00;
      }

      .main-button:active {
        transform: scale(0.95);
        box-shadow: 0 2px 4px var(--shadow-color);
      }

      .winner {
        color: #4caf50;
        font-weight: bold;
        animation: bounce 1s ease-in-out;
        text-shadow: 1px 1px 0 rgba(255, 255, 255, 0.5);
      }

      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(0.95);
        }
      }

      @keyframes bounce {
        0%,
        100% {
          transform: translateY(0);
        }
        50% {
          transform: translateY(-5px);
        }
      }

      @keyframes spin {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }

      @media (max-width: 360px) {
        :root {
          --container-width: 100%;
        }

        body {
          padding: 5px;
        }

        .game-board {
          gap: 0.25rem;
          padding: 0.35rem;
        }

        .cell {
          border-radius: 0.5rem;
        }

        .main-button {
          padding: 0.5rem;
          min-width: 90px;
          font-size: 0.75rem;
        }
      }

      @media (min-width: 361px) and (max-width: 640px) {
        body {
          padding: 10px;
        }

        .game-board {
          gap: 0.35rem;
          padding: 0.5rem;
        }

        .button-container {
          gap: 1rem;
        }
      }

      @media (min-width: 641px) {
        :root {
          --container-width: min(95%, 500px);
        }

        .cell:hover {
          transform: translateY(-3px);
          box-shadow: 0 8px 16px var(--shadow-color);
        }
      }

      @media (prefers-color-scheme: dark) {
        :root {
          --tg-theme-bg-color: #2d2d2d;
          --tg-theme-text-color: #fff8e1;
          --tg-theme-button-color: #ffa000;
          --highlight-color: rgba(255, 160, 0, 0.2);
          --shadow-color: rgba(0, 0, 0, 0.3);
        }

        body {
          background-image: linear-gradient(
            45deg,
            #2d2d2d 25%,
            #333333 25%,
            #333333 50%,
            #2d2d2d 50%,
            #2d2d2d 75%,
            #333333 75%,
            #333333 100%
          );
        }

        .cell {
          background: #3d3d3d;
          color: #ffd54f;
        }

        .game-info,
        .game-board {
          background: rgba(0, 0, 0, 0.2);
        }

        .status,
        .phase-indicator {
          background: rgba(255, 160, 0, 0.1);
          border-color: var(--tg-theme-button-color);
        }
      }
    </style>
  </head>
  <body>
    <div class="game-info">
      <div class="status" id="status">Welcome to Super Tic Tac Toe!</div>
      <div class="phase-indicator" id="phaseIndicator"></div>
      <div class="pieces-count" id="piecesCount"></div>
    </div>

    <div id="game-board" class="game-board"></div>

    <div class="button-container">
      <button class="main-button" id="joinBtn">Join Game</button>
      <button class="main-button" id="resetBtn">New Game</button>
    </div>

    <script>
      let tg = window.Telegram.WebApp;
      const API_URL = "https://pjimpsons.pythonanywhere.com";
      const updateQueue = new Set();
      let lastStateUpdate = Date.now();
      const POLLING_INTERVAL = 1000; // 1 second
      const RETRY_INTERVAL = 2000; // 2 seconds
      let retryCount = 0;
      const MAX_RETRIES = 3;

      let pollInterval;

      function stopPolling() {
        // Clear the polling interval
        if (pollInterval) {
          clearInterval(pollInterval);
          pollInterval = null;
        }

        // Reset retry count
        retryCount = 0;

        // Clear any pending state updates
        if (updateQueue) {
          updateQueue.clear();
        }

        // Remove visibility change listener if exists
        document.removeEventListener(
          "visibilitychange",
          handleVisibilityChange
        );

        // Reset connection state
        isPolling = false;

        return new Promise((resolve) => {
          // Ensure any pending operations are completed
          setTimeout(() => {
            console.log("Polling stopped successfully");
            resolve();
          }, 0);
        });
      }

      // Helper function to handle visibility changes
      function handleVisibilityChange() {
        if (document.hidden) {
          stopPolling();
        } else {
          startPolling();
        }
      }

      // Add visibility change listener when game starts
      function initializePollingListeners() {
        document.addEventListener("visibilitychange", handleVisibilityChange);
      }

      // Usage in cleanup
      async function cleanup() {
        await stopPolling();
        // Additional cleanup if needed
      }

      function startPolling() {
        if (pollInterval) stopPolling();
        pollInterval = setInterval(async () => {
          if (
            !document.hidden &&
            navigator.onLine &&
            !gameState.isProcessingMove
          ) {
            try {
              await checkGameState();
            } catch (error) {
              console.error("Polling error:", error);
              stopPolling();
              await recoverGameState();
            }
          }
        }, POLLING_INTERVAL);
      }

      // Debounce function for handling rapid state updates
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Throttle function for API calls
      function throttle(func, limit) {
        let inThrottle;
        return function (...args) {
          if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => (inThrottle = false), limit);
          }
        };
      }

      async function checkGameState(retryCount = 0) {
        try {
          const response = await makeApiCall("get_game_state", {});
          if (response.success) {
            gameState.update(response.gameState);
            return true;
          }
        } catch (error) {
          const backoffTime = Math.min(1000 * Math.pow(2, retryCount), 10000);
          await new Promise((resolve) => setTimeout(resolve, backoffTime));
          if (retryCount < 3) return checkGameState(retryCount + 1);
        }
        return false;
      }

      // Initialize the game
      document.addEventListener("DOMContentLoaded", () => {
        initializeGame();
      });

      class GameState {
        constructor() {
          this.state = {
            board: Array(4)
              .fill()
              .map(() => Array(4).fill("")),
            currentPlayer: "",
            mySymbol: null,
            phase: "placement",
            pieces: { O: 0, X: 0 },
            selectedPiece: null,
            lastMove: null,
            gameEnded: false,
            winner: null,
            players: {},
            joinTimeout: 60000,
            placementTimeout: 60000,
            lastActivityTime: Date.now(),
          };
          this.lastUpdate = Date.now();
          this.isProcessingMove = false;
          this.moveQueue = [];
          this.processingQueue = false;
        }

        shouldUpdate(newState) {
          if (!newState || Date.now() - this.lastUpdate < 100) return false;

          const relevantKeys = [
            "board",
            "currentPlayer",
            "phase",
            "pieces",
            "gameEnded",
            "winner",
          ];
          return relevantKeys.some(
            (key) =>
              JSON.stringify(this.state[key]) !== JSON.stringify(newState[key])
          );
        }

        update(newState) {
          if (!this.validateState(newState)) return;

          const changes = this.detectStateChanges(newState);
          if (Object.keys(changes).length === 0) return;

          this.state = {
            ...this.state,
            ...changes,
            mySymbol: this.state.mySymbol,
            selectedPiece: this.state.selectedPiece,
          };

          requestAnimationFrame(() => {
            this.updateUI();
            this.lastUpdate = Date.now();
          });
        }

        validateState(newState) {
          return (
            newState &&
            typeof newState === "object" &&
            Array.isArray(newState.board) &&
            newState.board.length === 4
          );
        }

        detectStateChanges(newState) {
          const changes = {};
          const keys = [
            "board",
            "currentPlayer",
            "phase",
            "pieces",
            "gameEnded",
            "winner",
          ];

          keys.forEach((key) => {
            if (
              JSON.stringify(this.state[key]) !== JSON.stringify(newState[key])
            ) {
              changes[key] = newState[key];
            }
          });
          return changes;
        }

        updateUI() {
          if (updateQueue.size > 0) return;

          ["board", "status", "players", "phase"].forEach((type) =>
            updateQueue.add(type)
          );

          requestAnimationFrame(() => {
            if (updateQueue.has("board")) updateBoard();
            if (updateQueue.has("status")) updateStatus();
            if (updateQueue.has("players")) updatePlayerDisplay();
            if (updateQueue.has("phase")) updatePhaseIndicator();
            updateQueue.clear();
          });
        }

        isValidTurn() {
          return (
            this.state.mySymbol &&
            this.state.currentPlayer === this.state.mySymbol &&
            !this.state.gameEnded &&
            !this.isProcessingMove &&
            (this.state.phase === "placement"
              ? this.state.pieces[this.state.mySymbol] < 4
              : true)
          );
        }

        isValidMove(row, col) {
          // First check if it's player's turn
          if (!this.isValidTurn()) {
            console.log("Turn validation failed:", {
              mySymbol: this.state.mySymbol,
              currentPlayer: this.state.currentPlayer,
              phase: this.state.phase,
            });
            return false;
          }

          if (this.state.phase === "movement") {
            // If no piece is selected and clicking own piece, allow selection of any of your pieces
            if (!this.state.selectedPiece) {
              const isOwnPiece =
                this.state.board[row][col] === this.state.mySymbol;
              console.log("Piece selection validation:", {
                position: { row, col },
                piece: this.state.board[row][col],
                isOwnPiece,
              });
              return isOwnPiece;
            }

            // If a piece is selected, allow movement to ANY empty tile
            console.log("Movement validation:", {
              from: this.state.selectedPiece,
              to: { row, col },
              targetCell: this.state.board[row][col],
              isEmpty: this.state.board[row][col] === "",
            });

            // Only check if target tile is empty
            return this.state.board[row][col] === "";
          }

          // Placement phase validation
          const isValidPlacement =
            this.state.board[row][col] === "" &&
            this.state.pieces[this.state.mySymbol] < 4;

          console.log("Placement validation:", {
            position: { row, col },
            isEmpty: this.state.board[row][col] === "",
            piecesPlaced: this.state.pieces[this.state.mySymbol],
            isValid: isValidPlacement,
          });

          return isValidPlacement;
        }

        async processMoveQueue() {
          if (this.processingQueue || this.moveQueue.length === 0) return;

          this.processingQueue = true;
          while (this.moveQueue.length > 0) {
            const move = this.moveQueue.shift();
            try {
              await this.processMove(move);
            } catch (error) {
              console.error("Move processing error:", error);
              if (this.isValidMove(move.row, move.col)) {
                this.moveQueue.unshift(move);
              }
            }
          }
          this.processingQueue = false;
        }

        queueMove(move) {
          this.moveQueue.push(move);
          this.processMoveQueue();
        }

        async processMove(move) {
          const { row, col, type } = move;
          let result;

          try {
            console.log("Processing move:", { row, col, type });

            if (type === "placement") {
              // Direct call to makeMove instead of handlePlacement
              result = await makeMove(row, col);
            } else {
              if (!this.state.selectedPiece) {
                this.state.selectedPiece = { row, col };
                this.updateUI();
                return true;
              }
              result = await makeMove(row, col, this.state.selectedPiece);
              this.state.selectedPiece = null;
            }

            console.log("Move result:", result);

            if (result) {
              this.state.lastMove = [row, col];
              this.updateUI();
            }

            return result;
          } catch (error) {
            console.error("Move processing error:", error);
            return false;
          }
        }

        async handleCellClick(event) {
          const row = parseInt(event.target.dataset.row);
          const col = parseInt(event.target.dataset.col);

          console.log("Cell clicked:", {
            row,
            col,
            phase: this.state.phase,
            selectedPiece: this.state.selectedPiece,
            currentPlayer: this.state.currentPlayer,
            mySymbol: this.state.mySymbol,
          });

          // Handle movement phase
          if (this.state.phase === "movement") {
            // Check for deselection first, before any other validation
            if (
              this.state.selectedPiece &&
              row === this.state.selectedPiece.row &&
              col === this.state.selectedPiece.col
            ) {
              console.log("Deselecting piece");
              this.state.selectedPiece = null;
              this.updateUI();
              return;
            }

            // Then proceed with regular move handling
            if (!this.isValidTurn()) {
              console.log("Not valid turn");
              return;
            }

            await this.handleMovement(row, col);
            return;
          }

          // Handle placement phase
          if (!this.isValidTurn()) {
            console.log("Not valid turn");
            return;
          }

          if (!this.isValidMove(row, col)) {
            console.log("Invalid move:", { row, col });
            return;
          }

          try {
            this.isProcessingMove = true;
            await this.processMove({ row, col, type: "placement" });
          } catch (error) {
            console.error("Move processing error:", error);
          } finally {
            this.isProcessingMove = false;
          }
        }

        async handlePlacement(row, col) {
          if (!this.isValidMove(row, col)) return false;
          return await makeMove(row, col);
        }

        async handleMovement(row, col) {
          console.log("Movement phase:", {
            selectedPiece: this.state.selectedPiece,
            currentBoard: this.state.board[row][col],
            mySymbol: this.state.mySymbol,
          });

          // If clicking already selected piece, deselect it
          if (
            this.state.selectedPiece &&
            row === this.state.selectedPiece.row &&
            col === this.state.selectedPiece.col
          ) {
            this.state.selectedPiece = null;
            this.updateUI();
            return true;
          }

          // If no piece selected and clicking own piece
          if (
            !this.state.selectedPiece &&
            this.state.board[row][col] === this.state.mySymbol
          ) {
            this.state.selectedPiece = { row, col };
            this.updateUI();
            return true;
          }

          // If piece selected and target is valid
          if (this.state.selectedPiece && this.isValidMove(row, col)) {
            const result = await makeMove(row, col, this.state.selectedPiece);
            this.state.selectedPiece = null;
            return result;
          }

          return false;
        }

        async makeMove(row, col, selectedPiece = null) {
          try {
            const response = await makeApiCall("make_move", {
              row,
              col,
              symbol: this.state.mySymbol,
              selectedPiece,
              chatId: tg.initDataUnsafe.chat?.id || "default",
              userId: tg.initDataUnsafe.user?.id,
            });

            if (response.success) {
              this.update(response.gameState);
              return true;
            }

            document.getElementById("status").textContent = response.message;
            return false;
          } catch (error) {
            console.error("Move error:", error);
            document.getElementById("status").textContent = "Error making move";
            return false;
          }
        }
      }

      const gameState = new GameState();

      // API handling with retry logic and caching
      async function makeApiCall(endpoint, data, retries = 3) {
        try {
          const response = await fetch(`${API_URL}/${endpoint}`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              ...data,
              chatId: tg.initDataUnsafe.chat?.id || "default",
              userId: tg.initDataUnsafe.user?.id,
              timestamp: Date.now(),
            }),
          });

          const result = await response.json();

          // Handle "already in game" as a special case
          if (
            result.message &&
            result.message.includes("already in the game")
          ) {
            return {
              success: false,
              isAlreadyJoined: true,
              message: result.message,
            };
          }

          return result;
        } catch (error) {
          console.error("API call error:", error);
          throw error;
        }
      }

      // Game actions with proper error handling
      async function makeMove(row, col, selectedPiece = null) {
        if (gameState.isProcessingMove) return false;

        try {
          gameState.isProcessingMove = true;
          const response = await makeApiCall("make_move", {
            row,
            col,
            symbol: gameState.state.mySymbol,
            selectedPiece,
          });

          if (response.success) {
            gameState.update(response.gameState);
            return true;
          }

          document.getElementById("status").textContent = response.message;
          return false;
        } catch (error) {
          console.error("Move error:", error);
          document.getElementById("status").textContent = "Error making move";
          return false;
        } finally {
          gameState.isProcessingMove = false;
        }
      }

      // Replace current handleJoin with this version
      async function handleJoin() {
        if (gameState.state.mySymbol) {
          document.getElementById(
            "status"
          ).textContent = `You are already in the game as ${gameState.state.mySymbol}`;
          return;
        }

        try {
          const username =
            tg.initDataUnsafe.user?.username || (await getUserName());
          const response = await makeApiCall("join_game", { username });

          if (response.success) {
            gameState.state.mySymbol = response.gameState.mySymbol;
            gameState.update(response.gameState);
            startPolling();
          }
          document.getElementById("status").textContent = response.success
            ? `You joined as ${response.gameState.mySymbol}`
            : response.message;
        } catch (error) {
          console.error("Join error:", error);
          document.getElementById("status").textContent = "Error joining game";
        }
      }

      async function resetGame() {
        try {
          const response = await makeApiCall("reset_game", {});
          if (response.success) {
            // Reset local game state
            gameState.state = {
              board: Array(4)
                .fill()
                .map(() => Array(4).fill("")),
              currentPlayer: "",
              mySymbol: null,
              phase: "placement",
              pieces: { O: 0, X: 0 },
              selectedPiece: null,
              lastMove: null,
              gameEnded: false,
              winner: null,
              players: {},
              joinTimeout: 60000,
              placementTimeout: 60000,
              lastActivityTime: Date.now(),
            };
            gameState.update(response.gameState);
            document.getElementById("status").textContent =
              "Game has been reset. Click Join Game to play.";
          }
        } catch (error) {
          console.error("Reset error:", error);
          document.getElementById("status").textContent =
            "Error resetting game";
        }
      }

      // Timeout checking
      function checkTimeouts() {
        const currentTime = Date.now();

        if (Object.keys(gameState.state.players).length < 2) {
          if (
            currentTime - gameState.state.lastActivityTime >
            gameState.state.joinTimeout
          ) {
            resetGame();
            document.getElementById("status").textContent =
              "Game reset due to inactivity. Click Join Game to play.";
            return;
          }
        }

        if (
          gameState.state.phase === "placement" &&
          (gameState.state.pieces.X > 0 || gameState.state.pieces.O > 0) &&
          currentTime - gameState.state.lastActivityTime >
            gameState.state.placementTimeout
        ) {
          resetGame();
          document.getElementById("status").textContent =
            "Game reset due to slow piece placement.";
          return;
        }
      }

      // UI Update Functions with requestAnimationFrame for performance
      function updateBoard() {
        const cells = document.querySelectorAll(".cell");
        const winningPattern = getWinningPattern(
          gameState.state.board,
          gameState.state.winner
        );

        requestAnimationFrame(() => {
          cells.forEach((cell, index) => {
            const row = Math.floor(index / 4);
            const col = index % 4;
            cell.textContent = gameState.state.board[row][col];
            cell.className = "cell";

            if (
              gameState.state.gameEnded &&
              gameState.state.winner &&
              winningPattern
            ) {
              if (winningPattern.some(([r, c]) => r === row && c === col)) {
                cell.classList.add("winner");
              }
            }

            if (
              gameState.state.selectedPiece &&
              row === gameState.state.selectedPiece.row &&
              col === gameState.state.selectedPiece.col
            ) {
              cell.classList.add("selected");
            }

            if (
              gameState.state.lastMove &&
              row === gameState.state.lastMove[0] &&
              col === gameState.state.lastMove[1]
            ) {
              cell.classList.add("last-move");
            }
          });
        });
      }

      function getWinningPattern(board, winner) {
        if (!winner) return null;

        // Check rows
        for (let i = 0; i < 4; i++) {
          if (board[i].every((cell) => cell === winner)) {
            return [
              [i, 0],
              [i, 1],
              [i, 2],
              [i, 3],
            ];
          }
        }

        // Check columns
        for (let j = 0; j < 4; j++) {
          if (board.every((row) => row[j] === winner)) {
            return [
              [0, j],
              [1, j],
              [2, j],
              [3, j],
            ];
          }
        }

        // Check diagonals
        if (
          board[0][0] === winner &&
          board[1][1] === winner &&
          board[2][2] === winner &&
          board[3][3] === winner
        ) {
          return [
            [0, 0],
            [1, 1],
            [2, 2],
            [3, 3],
          ];
        }

        if (
          board[0][3] === winner &&
          board[1][2] === winner &&
          board[2][1] === winner &&
          board[3][0] === winner
        ) {
          return [
            [0, 3],
            [1, 2],
            [2, 1],
            [3, 0],
          ];
        }

        // Check 2x2 squares
        for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 3; j++) {
            if (
              board[i][j] === winner &&
              board[i][j + 1] === winner &&
              board[i + 1][j] === winner &&
              board[i + 1][j + 1] === winner
            ) {
              return [
                [i, j],
                [i, j + 1],
                [i + 1, j],
                [i + 1, j + 1],
              ];
            }
          }
        }

        return null;
      }

      function updateStatus() {
        const statusDiv = document.getElementById("status");
        requestAnimationFrame(() => {
          if (gameState.state.gameEnded && gameState.state.winner) {
            const winnerName = gameState.state.players[gameState.state.winner];
            statusDiv.textContent = `${winnerName} (${gameState.state.winner}) has won! 🎉`;
            statusDiv.classList.add("winner");
          } else if (Object.keys(gameState.state.players).length < 2) {
            statusDiv.textContent = "Waiting for players...";
            statusDiv.classList.remove("winner");
          } else {
            const isMyTurn =
              gameState.state.currentPlayer === gameState.state.mySymbol;
            const currentPlayerName =
              gameState.state.players[gameState.state.currentPlayer];
            statusDiv.textContent = isMyTurn
              ? "Your turn!"
              : `Waiting for ${currentPlayerName}'s (${gameState.state.currentPlayer}) move...`;
            statusDiv.classList.remove("winner");
          }
        });
      }

      function updatePlayerDisplay() {
        const phaseDiv = document.getElementById("phaseIndicator");
        requestAnimationFrame(() => {
          const playersInfo = Object.entries(gameState.state.players)
            .map(([symbol, name]) => `${symbol}: ${name}`)
            .join(" vs ");
          phaseDiv.innerHTML = `${playersInfo}<br>${
            gameState.state.phase === "placement"
              ? "Place your pieces"
              : "Move your pieces"
          }`;
        });
      }

      function updatePhaseIndicator() {
        const piecesDiv = document.getElementById("piecesCount");
        requestAnimationFrame(() => {
          if (gameState.state.phase === "placement") {
            piecesDiv.textContent = `Pieces placed - X: ${gameState.state.pieces.X}/4, O: ${gameState.state.pieces.O}/4`;
          } else {
            piecesDiv.textContent = "Move phase: Move your pieces to win!";
          }
        });
      }

      // Game initialization
      function initializeGame() {
        const board = document.getElementById("game-board");
        board.innerHTML = "";

        const fragment = document.createDocumentFragment();
        for (let i = 0; i < 4; i++) {
          for (let j = 0; j < 4; j++) {
            const cell = document.createElement("div");
            cell.className = "cell";
            cell.dataset.row = i;
            cell.dataset.col = j;
            cell.addEventListener("click", (e) => gameState.handleCellClick(e));
            fragment.appendChild(cell);
          }
        }
        board.appendChild(fragment);

        updateBoard();
        tg.ready();
        tg.expand();
        startPolling();
      }

      // Event Listeners
      document.getElementById("joinBtn").addEventListener("click", handleJoin);
      document.getElementById("resetBtn").addEventListener("click", resetGame);

      // Initialize game
      initializeGame();
    </script>
  </body>
</html>
